package handlers

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"vulncard/backend/models"

	"github.com/gin-gonic/gin"
	"gopkg.in/yaml.v3"
)

// getConfigDir 获取配置目录路径
func getConfigDir() string {
	if configDir := os.Getenv("CONFIG_DIR"); configDir != "" {
		return configDir
	}
	// Docker 容器中的默认路径
	if _, err := os.Stat("/root/configs"); err == nil {
		return "/root/configs"
	}
	// 默认使用相对于 backend 目录的 configs 目录
	wd, _ := os.Getwd()
	// 如果当前在 backend 目录，则向上查找 configs
	if strings.HasSuffix(wd, "backend") {
		return filepath.Join(wd, "..", "configs")
	}
	return filepath.Join(wd, "configs")
}

// ListVulnerabilities 列出所有漏洞卡片
func ListVulnerabilities(c *gin.Context) {
	configDir := getConfigDir()

	files, err := ioutil.ReadDir(configDir)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "无法读取配置目录"})
		return
	}

	var cards []map[string]string
	for _, file := range files {
		if strings.HasSuffix(file.Name(), ".yaml") || strings.HasSuffix(file.Name(), ".yml") {
			name := strings.TrimSuffix(file.Name(), ".yaml")
			name = strings.TrimSuffix(name, ".yml")
			cards = append(cards, map[string]string{
				"id":   name,
				"name": name,
			})
		}
	}

	c.JSON(http.StatusOK, gin.H{"cards": cards})
}

// GetVulnerability 获取单个漏洞卡片
func GetVulnerability(c *gin.Context) {
	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "缺少漏洞ID"})
		return
	}

	configDir := getConfigDir()

	// 尝试 .yaml 和 .yml 扩展名
	var configPath string
	for _, ext := range []string{".yaml", ".yml"} {
		path := filepath.Join(configDir, id+ext)
		if _, err := os.Stat(path); err == nil {
			configPath = path
			break
		}
	}

	if configPath == "" {
		c.JSON(http.StatusNotFound, gin.H{"error": "未找到漏洞卡片"})
		return
	}

	data, err := ioutil.ReadFile(configPath)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "无法读取配置文件"})
		return
	}

	var card models.VulnerabilityCard
	if err := yaml.Unmarshal(data, &card); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("解析配置文件失败: %v", err)})
		return
	}

	c.JSON(http.StatusOK, card)
}

// SaveVulnerability 保存漏洞卡片
func SaveVulnerability(c *gin.Context) {
	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "缺少漏洞ID"})
		return
	}

	var card models.VulnerabilityCard
	if err := c.ShouldBindJSON(&card); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "无效的请求数据"})
		return
	}

	configDir := getConfigDir()

	data, err := yaml.Marshal(&card)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "序列化失败"})
		return
	}

	configPath := filepath.Join(configDir, id+".yaml")
	if err := ioutil.WriteFile(configPath, data, 0644); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "保存文件失败"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "保存成功"})
}
